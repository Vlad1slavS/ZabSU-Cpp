## Правило Пяти в C++

Правило Пяти в C++ — это принцип, касающийся управления ресурсами в классах, который расширяет предшествующее Правило Трех, добавляя две новые специальные функции для работы с перемещением объектов. Это правило стало особенно актуальным с введением семантики перемещения в стандарте C++11.

### Основные положения Правила Пяти

Правило Пяти утверждает, что если вы определяете любую из следующих пяти специальных функций-членов в классе, то вам, скорее всего, нужно определить или удалить все пять:

1. **Деструктор**: Освобождает ресурсы, занятые объектом.
2. **Конструктор копирования**: Создает новый объект как копию существующего.
3. **Оператор присваивания копированием**: Позволяет присваивать один объект другому.
4. **Конструктор перемещения**: Перемещает ресурсы из временного объекта в новый объект.
5. **Оператор присваивания перемещением**: Позволяет присваивать ресурсы из временного объекта в существующий объект.

### Зачем нужно Правило Пяти?

Правило Пяти помогает избежать утечек памяти и других ошибок управления ресурсами, обеспечивая правильное управление созданием и уничтожением объектов. Если вы определяете хотя бы одну из этих функций, это может означать, что ваш класс управляет ресурсами (например, динамически выделенной памятью), и вам следует явно определить все функции для корректного управления этими ресурсами.

### Пример реализации Правила Пяти

Рассмотрим пример класса, который управляет динамически выделенной памятью:

```cpp
#include <cstring>

class Resource {
private:
    char* data;

public:
    // Конструктор
    Resource(const char* str) {
        data = new char[strlen(str) + 1];
        strcpy(data, str);
    }

    // Деструктор
    ~Resource() {
        delete[] data;
    }

    // Конструктор копирования
    Resource(const Resource& other) {
        data = new char[strlen(other.data) + 1];
        strcpy(data, other.data);
    }

    // Оператор присваивания копированием
    Resource& operator=(const Resource& other) {
        if (this == &other) return *this; // Защита от самоназначения
        delete[] data; // Освобождаем старый ресурс
        data = new char[strlen(other.data) + 1];
        strcpy(data, other.data);
        return *this;
    }

    // Конструктор перемещения
    Resource(Resource&& other) noexcept : data(other.data) {
        other.data = nullptr; // Передаем владение ресурса
    }

    // Оператор присваивания перемещением
    Resource& operator=(Resource&& other) noexcept {
        if (this == &other) return *this; // Защита от самоназначения
        delete[] data; // Освобождаем старый ресурс
        data = other.data; // Передаем владение ресурса
        other.data = nullptr;
        return *this;
    }
};
```

### Когда использовать Правило Пяти?

- **Используйте Правило Пяти**, если ваш класс управляет ресурсами (например, памятью).
- Если ваш класс не управляет ресурсами напрямую (например, содержит другие объекты), рассмотрите возможность использования **Правила Ноля**, которое предполагает использование умных указателей и позволяет компилятору автоматически генерировать необходимые функции.

### Заключение

Правило Пяти является важным принципом в C++, который помогает разработчикам правильно управлять ресурсами и избегать ошибок, связанных с копированием и перемещением объектов. Следуя этому правилу, вы можете обеспечить безопасность и эффективность вашего кода при работе с динамическими ресурсами.

Citations:
[1] https://radioprog.ru/post/1567
[2] https://habr.com/ru/companies/otus/articles/704492/
[3] https://bookflow.ru/pravila-treh-pyati-i-nulya/
[4] https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D0%BE_%D1%82%D1%80%D1%91%D1%85_(C++)
[5] https://radioprog.ru/post/1568
[6] https://dzen.ru/b/ZfgGZUglqB4AntIQ
[7] https://learn.microsoft.com/ru-ru/cpp/cpp/enumerations-cpp?view=msvc-170
[8] https://metanit.com/cpp/tutorial/5.9.php