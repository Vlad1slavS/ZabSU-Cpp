## Правило Пяти в C++

Правило Пяти в C++ — это принцип, касающийся управления ресурсами в классах, который расширяет предшествующее Правило Трех, добавляя две новые специальные функции для работы с перемещением объектов. Это правило стало особенно актуальным с введением семантики перемещения в стандарте C++11.

### Основные положения Правила Пяти

Правило Пяти утверждает, что если вы определяете любую из следующих пяти специальных функций-членов в классе, то вам, скорее всего, нужно определить или удалить все пять:

1. **Деструктор**: Освобождает ресурсы, занятые объектом.
2. **Конструктор копирования**: Создает новый объект как копию существующего.
3. **Оператор присваивания копированием**: Позволяет присваивать один объект другому.
4. **Конструктор перемещения**: Перемещает ресурсы из временного объекта в новый объект.
5. **Оператор присваивания перемещением**: Позволяет присваивать ресурсы из временного объекта в существующий объект.

### Зачем нужно Правило Пяти?

Правило Пяти помогает избежать утечек памяти и других ошибок управления ресурсами, обеспечивая правильное управление созданием и уничтожением объектов. Если вы определяете хотя бы одну из этих функций, это может означать, что ваш класс управляет ресурсами (например, динамически выделенной памятью), и вам следует явно определить все функции для корректного управления этими ресурсами.

### Пример реализации Правила Пяти

Рассмотрим пример класса, который управляет динамически выделенной памятью:

```cpp
#include <cstring>

class Resource {
private:
    char* data;

public:
    // Конструктор
    Resource(const char* str) {
        data = new char[strlen(str) + 1];
        strcpy(data, str);
    }

    // Деструктор
    ~Resource() {
        delete[] data;
    }

    // Конструктор копирования
    Resource(const Resource& other) {
        data = new char[strlen(other.data) + 1];
        strcpy(data, other.data);
    }

    // Оператор присваивания копированием
    Resource& operator=(const Resource& other) {
        if (this == &other) return *this; // Защита от самоназначения
        delete[] data; // Освобождаем старый ресурс
        data = new char[strlen(other.data) + 1];
        strcpy(data, other.data);
        return *this;
    }

    // Конструктор перемещения
    Resource(Resource&& other) noexcept : data(other.data) {
        other.data = nullptr; // Передаем владение ресурса
    }

    // Оператор присваивания перемещением
    Resource& operator=(Resource&& other) noexcept {
        if (this == &other) return *this; // Защита от самоназначения
        delete[] data; // Освобождаем старый ресурс
        data = other.data; // Передаем владение ресурса
        other.data = nullptr;
        return *this;
    }
};
```

### Когда использовать Правило Пяти?

- **Используйте Правило Пяти**, если ваш класс управляет ресурсами (например, памятью).
- Если ваш класс не управляет ресурсами напрямую (например, содержит другие объекты), рассмотрите возможность использования **Правила Ноля**, которое предполагает использование умных указателей и позволяет компилятору автоматически генерировать необходимые функции.

